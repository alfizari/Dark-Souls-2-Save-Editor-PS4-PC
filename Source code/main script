import tkinter as tk
from tkinter import ttk, filedialog, messagebox
import os

# Constants
hex_pattern1_Fixed = '00 FF FF FF FF 00 00 00 00 00 00 00 00 00 00 00 00 FF FF FF FF 00 00 00 00 00 00 00 00 00 00 00 00 FF FF FF FF 00 00 00 00 00 00 00 00 00 00 00 00 FF FF FF FF 00 00 00 00 00 00 00 00 00 00 00 00 FF FF FF FF 00 00 00 00 00 00 00 00 00 00 00 00 FF FF FF FF 00 00 00 00 00 00 00 00 00 00 00 00 FF FF FF FF 00 00 00 00 00 00 00 00 00 00 00 00'
souls_distance = -219
possible_name_distances_for_name_tap = [-199]
key_offset_distance = 31205
search_range = 1000
hp_distance= -311
inventory_distance= 0
inventory_range= 80000
storage_box_distance = 36749   
drawer_range = 2500  

# Stats offsets
stats_offsets_for_stats_tap = {
    "Level": -223,
    "Vigor": -267,
    "Attunement": -263,
    "Endurance": -259,
    "Vitality": -227,
    "Strength": -255,
    "Dexterity": -251,
    "Intelligence": -247,
    "Faith": -243,
    "Luck": -239,
}

# Item hex patterns (Little-endian format) FOR KEY ITEMS 
item_hex_patterns = {
    "Lift Chamber Key": 'D1 07 00 40',
    "Sminventory Doll": 'D5 07 00 40',
    "Jailbreaker's Key": 'D7 07 00 40',
    "Jailer's Key Ring": 'D8 07 00 40',
    "Grave Key": 'D9 07 00 40',
    "Cell Key": 'DA 07 00 40',
    "Dungeon Ground Floor Key": 'DB 07 00 40',
    "Old Cell Key": 'DC 07 00 40',
    "Tower Key": 'DD 07 00 40',
    "Grand Archives Key": 'DE 07 00 40',
    "Tower Key (Duplicate)": 'DF 07 00 40',
    "Sminventory Lothric Banner": '36 08 00 40',
    "Contraption Key": '6B 08 00 40',
    "Bridge Key": 'D3 07 00 40',
    "Dungeon Ground Floor Key (Duplicate)": 'DB 07 00 40',
    "Braille Divine Sunlight Tome": '49 08 00 40',
    "Dark Sigil": 'EA 01 00 40',
    "Blood of the Dark Souls": '6E 08 00 40',
    "Young Grass Dew": '6F 08 00 40',
    "Sminventory Envoy Banner": '6C 08 00 40',
    "Hawkwood's Swordgrass": '5E 08 00 40',
    "Sage's Scroll": '54 08 00 40',
    "Logan's Scroll": '55 08 00 40',
    "Crystal Scroll": '56 08 00 40',
    "Great Swamp Pyromancy Tome": '4F 08 00 40',
    "Carthus Pyromancy Tome": '50 08 00 40',
    "Izalith Pyromancy Tome": '51 08 00 40',
    "Quelana Pyromancy Tome": '52 08 00 40',
    "Grave Warden Pyromancy Tome": '53 08 00 40'
}

replacement_items = item_hex_patterns.copy()

# for the rest of the items
from itemshex import inventory_item_hex_patterns

inventory_replacement_items = inventory_item_hex_patterns.copy()

# main window
window = tk.Tk()
window.title("Dark Souls 3 Save Editor")


# Global variables
file_path_var = tk.StringVar()
current_souls_var = tk.StringVar(value="N/A")
new_souls_var = tk.StringVar()
current_name_var = tk.StringVar(value="N/A")
new_name_var = tk.StringVar()
current_hp_var= tk.StringVar(value="N/A")
new_hp_var= tk.StringVar()
found_items = []
inventory_items = []
found_items_with_quantity = []
found_storage_items_with_quantity = []

# Variables to hold current and new values for each stat
current_stats_vars = {stat: tk.StringVar(value="N/A") for stat in stats_offsets_for_stats_tap}
new_stats_vars = {stat: tk.StringVar() for stat in stats_offsets_for_stats_tap}

# Utility Functions
def find_hex_offset(file_path, hex_pattern):
    pattern_bytes = bytes.fromhex(hex_pattern)
    with open(file_path, 'rb') as file:
        chunk_size = 100034
        offset = 0
        while chunk := file.read(chunk_size):
            if pattern_bytes in chunk:
                byte_offset = chunk.index(pattern_bytes)
                return offset + byte_offset
            offset += chunk_size
    return None

def calculate_offset2(offset1, distance):
    return offset1 + distance

def find_value_at_offset(file_path, offset, byte_size=4):
    with open(file_path, 'rb') as file:
        file.seek(offset)
        value_bytes = file.read(byte_size)
        if len(value_bytes) == byte_size:
            return int.from_bytes(value_bytes, 'little')
    return None

def write_value_at_offset(file_path, offset, value, byte_size=4):
    value_bytes = value.to_bytes(byte_size, 'little')
    with open(file_path, 'r+b') as file:
        file.seek(offset)
        file.write(value_bytes)

# Functions for character name
def find_character_name(file_path, offset, byte_size=32):
    with open(file_path, 'rb') as file:
        file.seek(offset)
        value_bytes = file.read(byte_size)
        name_chars = []
        for i in range(0, len(value_bytes), 2):
            char_byte = value_bytes[i]
            if char_byte == 0:
                break
            if 32 <= char_byte <= 126:
                name_chars.append(chr(char_byte))
            else:
                name_chars.append('.')
        return ''.join(name_chars)

def write_character_name(file_path, offset, new_name, byte_size=32):
    name_bytes = []
    for char in new_name:
        name_bytes.append(ord(char))
        name_bytes.append(0) 
    name_bytes = name_bytes[:byte_size]
    with open(file_path, 'r+b') as file:
        file.seek(offset)
        file.write(bytes(name_bytes))

# Function to open the file
def open_file():
    global name_offset
    file_path = filedialog.askopenfilename(filetypes=[("inventory Files", "*")])
    if file_path:
        file_path_var.set(file_path)
        file_name_label.config(text=f"File: {os.path.basename(file_path)}")
        
        offset1 = find_hex_offset(file_path, hex_pattern1_Fixed)
        if offset1 is not None:
            # Display Souls value
            souls_offset = calculate_offset2(offset1, souls_distance)
            current_souls = find_value_at_offset(file_path, souls_offset)
            current_souls_var.set(current_souls if current_souls is not None else "N/A")

            # Display character name
            for distance in possible_name_distances_for_name_tap:
                name_offset = calculate_offset2(offset1, distance)
                current_name = find_character_name(file_path, name_offset)
                if current_name and current_name != "N/A":
                    current_name_var.set(current_name)
                    break
            else:
                current_name_var.set("N/A")

            # Display current values for each stat
            for stat, distance in stats_offsets_for_stats_tap.items():
                stat_offset = calculate_offset2(offset1, distance)
                current_stat_value = find_value_at_offset(file_path, stat_offset)
                current_stats_vars[stat].set(current_stat_value if current_stat_value is not None else "N/A")

            # For health (test)
            if isinstance(hp_distance, int):
                # Handle the case where hp_distance is a single value
                hp_offset = calculate_offset2(offset1, hp_distance)
                current_hp = find_value_at_offset(file_path, hp_offset)
                current_hp_var.set(current_hp if current_hp is not None else "N/A")
            else:
                # Handle the case where hp_distance is iterable
                for distance in hp_distance:
                    hp_offset = calculate_offset2(offset1, distance)
                    current_hp = find_value_at_offset(file_path, hp_offset)
                    if current_hp and current_hp != "N/A":
                        current_hp_var.set(current_hp)
                        break
                else:
                    current_hp_var.set("N/A")

            # Automatically refresh the item list for the Items tab
            refresh_storage_quantity_list(file_path)  # Refresh storage box items
            refresh_item_list(file_path)
            inventory_refresh_item_list(file_path)
            
        else:
            messagebox.showerror("Pattern Not Found", "Pattern not found in the file.")


# Functions to update values
def update_souls_value():
    file_path = file_path_var.get()
    if not file_path or not new_souls_var.get():
        messagebox.showerror("Input Error", "Please fill in the file path and new Souls value!")
        return
    
    try:
        new_souls_value = int(new_souls_var.get())
    except ValueError:
        messagebox.showerror("Invalid Input", "Please enter a valid decimal number for Souls.")
        return

    offset1 = find_hex_offset(file_path, hex_pattern1_Fixed)
    if offset1 is not None:
        souls_offset = calculate_offset2(offset1, souls_distance)
        write_value_at_offset(file_path, souls_offset, new_souls_value)
        messagebox.showinfo("Success", f"Souls value updated to {new_souls_value}. Open Save Again to see if applied")
    else:
        messagebox.showerror("Pattern Not Found", "Pattern not found in the file.")

#------------------------HP
def update_hp_value():
    file_path = file_path_var.get()
    if not file_path or not new_hp_var.get():
        messagebox.showerror("Input Error", "Please fill in the file path and new hp value!")
        return
    
    try:
        new_hp_value = int(new_hp_var.get())
    except ValueError:
        messagebox.showerror("Invalid Input", "Please enter a valid decimal number for hp.")
        return

    offset1 = find_hex_offset(file_path, hex_pattern1_Fixed)
    if offset1 is not None:
        hp_offset = calculate_offset2(offset1, hp_distance)
        write_value_at_offset(file_path, hp_offset, new_hp_value)
        messagebox.showinfo("Success", f"Hp value updated to {new_hp_value}. Open Save Again to see if applied")
    else:
        messagebox.showerror("Pattern Not Found", "Pattern not found in the file.")


def update_character_name():
    file_path = file_path_var.get()
    new_name = new_name_var.get()

    if not file_path or not new_name:
        messagebox.showerror("Input Error", "Please fill in the file path and new character name!")
        return

    write_character_name(file_path, name_offset, new_name)
    messagebox.showinfo("Success", f"Character name updated to '{new_name}'.")
    current_name_var.set(new_name)

def update_stat(stat):
    file_path = file_path_var.get()
    if not file_path or not new_stats_vars[stat].get():
        messagebox.showerror("Input Error", f"Please fill in the new value for {stat}.")
        return

    try:
        new_stat_value = int(new_stats_vars[stat].get())
    except ValueError:
        messagebox.showerror("Invalid Input", f"Please enter a valid decimal number for {stat}.")
        return

    offset1 = find_hex_offset(file_path, hex_pattern1_Fixed)
    if offset1 is not None:
        stat_offset = calculate_offset2(offset1, stats_offsets_for_stats_tap[stat])
        write_value_at_offset(file_path, stat_offset, new_stat_value)
        messagebox.showinfo("Success", f"{stat} updated to {new_stat_value}.")
        current_stats_vars[stat].set(new_stat_value)
    else:
        messagebox.showerror("Pattern Not Found", "Pattern not found in the file.")

# Item-related functions
def find_key_items(file_path, key_offset):
    global found_items
    found_items = []
    with open(file_path, 'rb') as file:
        file.seek(key_offset)
        data_chunk = file.read(search_range)
        for item_name, item_hex in item_hex_patterns.items():
            item_bytes = bytes.fromhex(item_hex)
            if item_bytes in data_chunk:
                found_items.append(item_name)
    return found_items

# Inventory items

def find_inventory_items(file_path, inventory_distance):
    global inventory_items
    inventory_items = []

    with open(file_path, 'rb') as file:
        # Try searching with slight adjustments to the offset
        for offset_adjustment in range(-16, 17):
            adjusted_offset = inventory_distance + offset_adjustment
            file.seek(adjusted_offset)
            data_chunk = file.read(inventory_range)
            for inventory_item_name, inventory_item_hex in inventory_item_hex_patterns.items():
                item_bytes = bytes.fromhex(inventory_item_hex)
                if item_bytes in data_chunk:
                    inventory_items.append(inventory_item_name)
                    
            if inventory_items:
                # If items are found at this offset, stop adjusting further
                break

    return inventory_items

# Update item quantity in storage box
def update_item_quantity_in_file(file_path, item_offset, new_quantity_var):
    try:
        # Retrieve the new quantity value from the user input
        new_quantity = int(new_quantity_var.get())

        # Convert the quantity to bytes (2 bytes, little-endian)
        quantity_bytes = new_quantity.to_bytes(2, 'little')

        # Update the file with the new quantity value
        with open(file_path, 'r+b') as file:
            # Adjust the item_offset to point to the quantity bytes, which are located right after the item's hex
            quantity_offset = item_offset + len(bytes.fromhex(item_hex_patterns["Lift Chamber Key"]))
            file.seek(quantity_offset)
            file.write(quantity_bytes)

        # Inform the user of success and refresh the list
        messagebox.showinfo("Success", f"Quantity updated to {new_quantity}.")
        refresh_storage_quantity_list(file_path)  # Refresh the list after updating

    except ValueError:
        # Handle invalid input
        messagebox.showerror("Invalid Input", "Please enter a valid quantity.")

# Refresh storage quantity list
def refresh_storage_quantity_list(file_path):
    storage_offset = find_hex_offset(file_path, hex_pattern1_Fixed) + storage_box_distance
    updated_items = find_storage_items_with_quantity(file_path, storage_offset, drawer_range)

    # Clear the previous list and display the updated items
    for widget in storage_list_frame.winfo_children():
        widget.destroy()

    if updated_items:
        for item_name, quantity, item_offset in updated_items:
            item_frame = tk.Frame(storage_list_frame)
            item_frame.pack(fill="x", padx=10, pady=5)

            item_label = tk.Label(item_frame, text=f"{item_name} (Quantity: {quantity})", anchor="w")
            item_label.pack(side="left", fill="x", padx=5)

            new_quantity_var = tk.StringVar()
            new_quantity_entry = tk.Entry(item_frame, textvariable=new_quantity_var, width=10)
            new_quantity_entry.pack(side="left", padx=5)

            update_button = tk.Button(item_frame, text="Update Quantity", command=lambda item_offset=item_offset, new_quantity_var=new_quantity_var: update_item_quantity_in_file(file_path, item_offset, new_quantity_var))
            update_button.pack(side="right", padx=5)
    else:
        messagebox.showinfo("Info", "No items found.")


def find_storage_items_with_quantity(file_path, storage_offset, storage_range):
    global found_storage_items_with_quantity
    found_storage_items_with_quantity = []
    with open(file_path, 'rb') as file:
        file.seek(storage_offset)
        data_chunk = file.read(storage_range)
        for item_name, item_hex in {**item_hex_patterns, **inventory_item_hex_patterns}.items():
            item_bytes = bytes.fromhex(item_hex)
            idx = 0
            while (idx := data_chunk.find(item_bytes, idx)) != -1:
                quantity_offset = idx + len(item_bytes)
                quantity_bytes = data_chunk[quantity_offset:quantity_offset + 2]
                quantity = int.from_bytes(quantity_bytes, 'little')
                found_storage_items_with_quantity.append((item_name, quantity, storage_offset + idx))
                idx += len(item_bytes) + 2
    return found_storage_items_with_quantity
def replace_item(file_path, item_name, replacement_hex):
    replacement_bytes = bytes.fromhex(replacement_hex)
    key_offset = find_hex_offset(file_path, hex_pattern1_Fixed) + key_offset_distance
    
    with open(file_path, 'r+b') as file:
        file.seek(key_offset)
        data_chunk = file.read(search_range)
        item_bytes = bytes.fromhex(item_hex_patterns[item_name])
        item_offset = data_chunk.find(item_bytes)
        
        if item_offset != -1:
            file.seek(key_offset + item_offset)
            file.write(replacement_bytes)
            
            # After replacing, update the found items list
            found_items[found_items.index(item_name)] = item_name  # Replace the item in the list
            
            # Refresh the item list automaticinventoryy after the replacement
            refresh_item_list(file_path)
            messagebox.showinfo("Success", f"{item_name} has been replaced.")
            # Close the replacement window
            window2.destroy()
        else:
            messagebox.showerror("Not Found", f"Failed to find {item_name} to replace.")
 # Refresh item list after replacement
    refresh_item_list(file_path)

#////////////// inven item
def replace_inventory_item(file_path, inventory_item_name, inventory_replacement_hex):
    inventory_replacement_bytes = bytes.fromhex(inventory_replacement_hex)
    base_offset = find_hex_offset(file_path, hex_pattern1_Fixed)
    if base_offset is None:
        messagebox.showerror("Pattern Not Found", "Base hex pattern not found in the file.")
        return

    inventory_item_offset = base_offset + inventory_distance

    with open(file_path, 'r+b') as file:
        file.seek(inventory_item_offset)
        all_data_chunk = file.read(inventory_range)
        
        inventory_item_bytes = bytes.fromhex(inventory_item_hex_patterns[inventory_item_name])
        item_position = all_data_chunk.find(inventory_item_bytes)
        
        if item_position != -1:
            actual_offset = inventory_item_offset + item_position
            file.seek(actual_offset)
            file.write(inventory_replacement_bytes)
            
            # Refresh the item list after the replacement
            inventory_refresh_item_list(file_path)
            messagebox.showinfo("Success", f"{inventory_item_name} has been replaced.")
            window2.destroy()  # Close replacement window
        else:
            messagebox.showerror("Not Found", f"Failed to find {inventory_item_name} to replace.")
def refresh_item_list(file_path):
    key_offset = find_hex_offset(file_path, hex_pattern1_Fixed) + key_offset_distance
    updated_items = find_key_items(file_path, key_offset)
    
    # Clear the previous list and display the updated items
    for widget in items_list_frame.winfo_children():
        widget.destroy()

    if updated_items:
        for item in updated_items:
            item_frame = tk.Frame(items_list_frame)
            item_frame.pack(fill="x", padx=10, pady=5)
            
            item_label = tk.Label(item_frame, text=item, anchor="w")
            item_label.pack(side="left", fill="x", padx=5)
            
            replace_button = tk.Button(item_frame, text="Replace", command=lambda item=item: choose_replacement(item))
            replace_button.pack(side="right", padx=5)
    else:
        messagebox.showinfo("Info", "No items found.")
    #]]]]]] inevn 

def inventory_refresh_item_list(file_path):
    inventory_item_offset = find_hex_offset(file_path, hex_pattern1_Fixed) + inventory_distance
    updated_items = find_inventory_items(file_path, inventory_item_offset)
    
    # Clear the previous list and display the updated items
    for widget in Inven_list_frame.winfo_children():
        widget.destroy()

    if updated_items:
        for item in updated_items:
            item_frame = tk.Frame(Inven_list_frame)
            item_frame.pack(fill="x", padx=10, pady=5)
            
            item_label = tk.Label(item_frame, text=item, anchor="w")
            item_label.pack(side="left", fill="x", padx=5)
            
            replace_button = tk.Button(item_frame, text="Replace", command=lambda item=item: inventory_choose_replacement(item))
            replace_button.pack(side="right", padx=5)
    else:
        messagebox.showinfo("Info", "No items found.")

def choose_replacement(item):
    global window2
    window2 = tk.Toplevel(window)
    window2.title(f"Choose replacement for {item}")
    
    grid_frame = tk.Frame(window2)
    grid_frame.pack(pady=10)

    col = 0
    row = 0
    for name, replacement_hex in replacement_items.items():
        replacement_button = tk.Button(grid_frame, text=name,
                                      command=lambda name=name: replace_item(file_path_var.get(), item, replacement_items[name]))
        replacement_button.grid(row=row, column=col, padx=5, pady=5)
        
        col += 1
        if col > 3:
            col = 0
            row += 1
#]]]]]]]]] inevn  
def inventory_choose_replacement(item):
    global window2
    window2 = tk.Toplevel(window)
    window2.title(f"Choose replacement for {item}")

    # Create a canvas and scrollbar for the replacement window
    canvas = tk.Canvas(window2)
    scrollbar = ttk.Scrollbar(window2, orient="vertical", command=canvas.yview)

    # Create a frame inside the canvas to hold the replacement buttons
    grid_frame = tk.Frame(canvas)

    # Attach the scrollbar to the canvas
    canvas.configure(yscrollcommand=scrollbar.set)

    # Pack the canvas and scrollbar in the replacement window
    canvas.pack(side="left", fill="both", expand=True)
    scrollbar.pack(side="right", fill="y")

    # Create a window inside the canvas for the grid_frame
    canvas_frame = canvas.create_window((0, 0), window=grid_frame, anchor="nw")

    # Configure grid_frame to update the canvas scroll region
    def update_scroll_region(event):
        canvas.configure(scrollregion=canvas.bbox("inventory"))

    grid_frame.bind("<Configure>", update_scroll_region)

    # Search bar to filter items
    search_var = tk.StringVar()

    def update_replacement_buttons():
        # Clear previous buttons
        for widget in grid_frame.winfo_children():
            widget.destroy()

        # Get search term and filter items
        search_term = search_var.get().lower()

        # Populate the grid frame with replacement buttons that match the search term
        col = 0
        row = 0
        for name, replacement_hex in inventory_replacement_items.items():
            if search_term in name.lower():
                replacement_button = tk.Button(grid_frame, text=name,
                                               command=lambda name=name: replace_inventory_item(file_path_var.get(), item, inventory_replacement_items[name]))
                replacement_button.grid(row=row, column=col, padx=5, pady=5)

                col += 1
                if col > 3:
                    col = 0
                    row += 1

    # Entry widget for searching
    search_entry = tk.Entry(window2, textvariable=search_var, width=30)
    search_entry.pack(pady=10)
    search_entry.bind("<KeyRelease>", lambda event: update_replacement_buttons())

    # Initialize buttons
    update_replacement_buttons()



# UI Layout
file_open_frame = tk.Frame(window)
file_open_frame.pack(fill="x", padx=10, pady=5)

tk.Button(file_open_frame, text="Open Save File", command=open_file).pack(side="left", padx=5)
file_name_label = tk.Label(file_open_frame, text="No file selected", anchor="w")
file_name_label.pack(side="left", padx=10, fill="x")

notebook = ttk.Notebook(window)

# Adding the tabs (Souls, Character Name, Stats, Items)
# Souls Tab
souls_tab = ttk.Frame(notebook)
tk.Label(souls_tab, text="Current Souls:").grid(row=0, column=0, padx=10, pady=10, sticky="e")
tk.Label(souls_tab, textvariable=current_souls_var).grid(row=0, column=1, padx=10, pady=10)
tk.Label(souls_tab, text="New Souls Value (MAX 999999999):").grid(row=1, column=0, padx=10, pady=10, sticky="e")
tk.Entry(souls_tab, textvariable=new_souls_var, width=20).grid(row=1, column=1, padx=10, pady=10)
tk.Button(souls_tab, text="Update Souls", command=update_souls_value).grid(row=2, column=0, columnspan=2, pady=20)


# Character Tab
name_tab = ttk.Frame(notebook)
tk.Label(name_tab, text="Current Character Name:").grid(row=0, column=0, padx=10, pady=10, sticky="e")
tk.Label(name_tab, textvariable=current_name_var).grid(row=0, column=1, padx=10, pady=10)
tk.Label(name_tab, text="New Character Name:").grid(row=1, column=0, padx=10, pady=10, sticky="e")
tk.Entry(name_tab, textvariable=new_name_var, width=20).grid(row=1, column=1, padx=10, pady=10)
tk.Button(name_tab, text="Update Name", command=update_character_name).grid(row=2, column=0, columnspan=2, pady=20)


#for hp
tk.Label(name_tab, text="Current HP:").grid(row=5, column=0, padx=10, pady=10, sticky="e")
tk.Label(name_tab, textvariable=current_hp_var).grid(row=5, column=1, padx=10, pady=10)
tk.Label(name_tab, text="New HP:").grid(row=7, column=0, padx=10, pady=10, sticky="e")
tk.Entry(name_tab, textvariable=new_hp_var, width=20).grid(row=7, column=1, padx=10, pady=10)
tk.Button(name_tab, text="Update HP", command=update_hp_value).grid(row=8, column=0, columnspan=2, pady=20)

# Stats Tab
stats_tab = ttk.Frame(notebook)
for idx, (stat, stat_offset) in enumerate(stats_offsets_for_stats_tap.items()):
    tk.Label(stats_tab, text=f"Current {stat}:").grid(row=idx, column=0, padx=10, pady=5, sticky="e")
    tk.Label(stats_tab, textvariable=current_stats_vars[stat]).grid(row=idx, column=1, padx=10, pady=5)
    tk.Entry(stats_tab, textvariable=new_stats_vars[stat], width=10).grid(row=idx, column=2, padx=10, pady=5)
    tk.Button(stats_tab, text=f"Update {stat}", command=lambda s=stat: update_stat(s)).grid(row=idx, column=3, padx=10, pady=5)

# Storage Box Tab
storage_box_tab = ttk.Frame(window)

storage_list_frame = tk.Frame(storage_box_tab)
storage_list_frame.pack(fill="x", padx=10, pady=5)

refresh_storage_button = tk.Button(storage_box_tab, text="Refresh Storage Box with Quantity", command=lambda: refresh_storage_quantity_list(file_path_var.get()))
refresh_storage_button.pack(pady=10)

# Items Tab
items_tab = ttk.Frame(notebook)
items_list_frame = tk.Frame(items_tab)
items_list_frame.pack(fill="x", padx=10, pady=5)
refresh_button = tk.Button(items_tab, text="Refresh Items List", command=lambda: refresh_item_list(file_path_var.get()))
refresh_button.pack(pady=10)

notebook.pack(expand=1, fill="both")
# Inventory Tab with Scrollable Frame
Inven_tab = ttk.Frame(notebook)

# Create a canvas and a scrollbar
canvas = tk.Canvas(Inven_tab)
scrollbar = ttk.Scrollbar(Inven_tab, orient="vertical", command=canvas.yview)

# Create a frame inside the canvas to hold the inventory items
Inven_list_frame = tk.Frame(canvas)

# Attach the scrollbar to the canvas
canvas.configure(yscrollcommand=scrollbar.set)

# Pack the canvas and scrollbar in the inventory tab
canvas.pack(side="left", fill="both", expand=True)
scrollbar.pack(side="right", fill="y")

# Create a window inside the canvas for the Inven_list_frame
canvas_frame = canvas.create_window((0, 0), window=Inven_list_frame, anchor="nw")

# Configure Inven_list_frame to update the canvas scroll region
def update_scroll_region(event):
    canvas.configure(scrollregion=canvas.bbox("all"))

Inven_list_frame.bind("<Configure>", update_scroll_region)

# Inventory Tab with Scrollable Frame
Inven_tab = ttk.Frame(notebook)

# Create a canvas and a scrollbar for the inventory
inventory_canvas = tk.Canvas(Inven_tab)
inventory_scrollbar = ttk.Scrollbar(Inven_tab, orient="vertical", command=inventory_canvas.yview)

# Create a frame inside the canvas to hold the inventory items
inventory_list_frame = tk.Frame(inventory_canvas)

# Attach the scrollbar to the canvas
inventory_canvas.configure(yscrollcommand=inventory_scrollbar.set)

# Pack the canvas and scrollbar in the inventory tab
inventory_canvas.pack(side="left", fill="both", expand=True)
inventory_scrollbar.pack(side="right", fill="y")

# Create a window inside the canvas for the inventory_list_frame
inventory_canvas_frame = inventory_canvas.create_window((0, 0), window=inventory_list_frame, anchor="nw")

# Function to update the scroll region to include the full content
def update_inventory_scroll_region(event):
    inventory_canvas.configure(scrollregion=inventory_canvas.bbox("all"))

# Bind the configuration event of inventory_list_frame to update the scroll region
inventory_list_frame.bind("<Configure>", update_inventory_scroll_region)

# Function to refresh inventory items list
def inventory_refresh_item_list(file_path):
    inventory_item_offset = find_hex_offset(file_path, hex_pattern1_Fixed) + inventory_distance
    updated_items = find_inventory_items(file_path, inventory_item_offset)

    # Clear the previous list and display the updated items
    for widget in inventory_list_frame.winfo_children():
        widget.destroy()

    if updated_items:
        for item in updated_items:
            item_frame = tk.Frame(inventory_list_frame)
            item_frame.pack(fill="x", padx=10, pady=5)

            item_label = tk.Label(item_frame, text=item, anchor="w")
            item_label.pack(side="left", fill="x", padx=5)

            replace_button = tk.Button(item_frame, text="Replace", command=lambda item=item: inventory_choose_replacement(item))
            replace_button.pack(side="right", padx=5)
    else:
        messagebox.showinfo("Info", "No items found.")





# Add a refresh button for the inventory list
refresh_button = tk.Button(Inven_tab, text="Refresh Inventory List", command=lambda: inventory_refresh_item_list(file_path_var.get()))
refresh_button.pack(pady=10)


# Define specific refresh functions for each tab
def refresh_souls_tab():
    offset1 = find_hex_offset(file_path_var.get(), hex_pattern1_Fixed)
    if offset1 is not None:
        souls_offset = calculate_offset2(offset1, souls_distance)
        current_souls = find_value_at_offset(file_path_var.get(), souls_offset)
        current_souls_var.set(current_souls if current_souls is not None else "N/A")

def refresh_character_tab():
    offset1 = find_hex_offset(file_path_var.get(), hex_pattern1_Fixed)
    if offset1 is not None:
        for distance in possible_name_distances_for_name_tap:
            name_offset = calculate_offset2(offset1, distance)
            current_name = find_character_name(file_path_var.get(), name_offset)
            if current_name and current_name != "N/A":
                current_name_var.set(current_name)
                break
        else:
            current_name_var.set("N/A")

        hp_offset = calculate_offset2(offset1, hp_distance)
        current_hp = find_value_at_offset(file_path_var.get(), hp_offset)
        current_hp_var.set(current_hp if current_hp is not None else "N/A")

def refresh_stats_tab():
    offset1 = find_hex_offset(file_path_var.get(), hex_pattern1_Fixed)
    if offset1 is not None:
        for stat, distance in stats_offsets_for_stats_tap.items():
            stat_offset = calculate_offset2(offset1, distance)
            current_stat_value = find_value_at_offset(file_path_var.get(), stat_offset)
            current_stats_vars[stat].set(current_stat_value if current_stat_value is not None else "N/A")

def refresh_items_tab():
    key_offset = find_hex_offset(file_path_var.get(), hex_pattern1_Fixed) + key_offset_distance
    refresh_item_list(file_path_var.get())

def refresh_storage_box_tab():
    storage_offset = find_hex_offset(file_path_var.get(), hex_pattern1_Fixed) + storage_box_distance
    refresh_storage_quantity_list(file_path_var.get())

def refresh_Inven_tab():
    inventory_refresh_item_list(file_path_var.get())




def refresh_on_click():
    refresh_souls_tab()
    refresh_character_tab()


def refresh_souls_tab():
    offset1 = find_hex_offset(file_path_var.get(), hex_pattern1_Fixed)
    if offset1 is not None:
        souls_offset = calculate_offset2(offset1, souls_distance)
        current_souls = find_value_at_offset(file_path_var.get(), souls_offset)
        current_souls_var.set(current_souls if current_souls is not None else "N/A")

def refresh_character_tab():
    offset1 = find_hex_offset(file_path_var.get(), hex_pattern1_Fixed)
    if offset1 is not None:
        for distance in possible_name_distances_for_name_tap:
            name_offset = calculate_offset2(offset1, distance)
            current_name = find_character_name(file_path_var.get(), name_offset)
            if current_name and current_name != "N/A":
                current_name_var.set(current_name)
                break
        else:
            current_name_var.set("N/A")

        hp_offset = calculate_offset2(offset1, hp_distance)
        current_hp = find_value_at_offset(file_path_var.get(), hp_offset)
        current_hp_var.set(current_hp if current_hp is not None else "N/A")

# Wrap each button command in Souls and Character tabs to refresh after the command executes
def update_souls_value_and_refresh():
    update_souls_value()
    refresh_on_click()

def update_character_name_and_refresh():
    update_character_name()
    refresh_on_click()

def update_hp_value_and_refresh():
    update_hp_value()
    refresh_on_click()

# Bind these modified functions to each button's command in the "Souls" and "Character" tabs
# Souls Tab
tk.Button(souls_tab, text="Update Souls", command=update_souls_value_and_refresh).grid(row=2, column=0, columnspan=2, pady=20)

# Character Tab
tk.Button(name_tab, text="Update Name", command=update_character_name_and_refresh).grid(row=2, column=0, columnspan=2, pady=20)
tk.Button(name_tab, text="Update HP", command=update_hp_value_and_refresh).grid(row=8, column=0, columnspan=2, pady=20)


# Add the inventory tab to the notebook
notebook.add(Inven_tab, text="Inventory")
# Storage Box Tab with Scrollable Frame
storage_box_tab = ttk.Frame(notebook)

# Create a canvas and a scrollbar for the storage box
canvas = tk.Canvas(storage_box_tab)
scrollbar = ttk.Scrollbar(storage_box_tab, orient="vertical", command=canvas.yview)

# Create a frame inside the canvas to hold the storage items
storage_list_frame = tk.Frame(canvas)

# Attach the scrollbar to the canvas
canvas.configure(yscrollcommand=scrollbar.set)

# Pack the canvas and scrollbar in the storage box tab
canvas.pack(side="left", fill="both", expand=True)
scrollbar.pack(side="right", fill="y")

# Create a window inside the canvas for the storage_list_frame
canvas_frame = canvas.create_window((0, 0), window=storage_list_frame, anchor="nw")

# Function to update the scroll region to include the full content
def update_storage_scroll_region(event):
    canvas.configure(scrollregion=canvas.bbox("all"))

# Bind the configuration event of storage_list_frame to update the scroll region
storage_list_frame.bind("<Configure>", update_storage_scroll_region)

inventory_text = """
DO NOT REPLACE ANY ITEM THAT YOU ARE CURRENTLY HAVE EQUIPED.
"""


inventory_label = tk.Label(Inven_tab, text=inventory_text, wraplength=400, justify="left", anchor="nw")
inventory_label.pack(padx=10, pady=10, fill="x") 

storage_text = """
600 IS THE MAXIMIM.
"""


storage_label = tk.Label(storage_box_tab, text=storage_text, wraplength=400, justify="left", anchor="nw")
storage_label.pack(padx=10, pady=10, fill="x") 

# Add tabs to notebook and display
notebook.add(souls_tab, text="Souls")

notebook.add(name_tab, text="Character (OFFLINE ONLY)")

notebook.add(stats_tab, text="Stats (OFFLINE ONLY)")

notebook.add(Inven_tab, text="Inventory")

notebook.add(items_tab, text="Key Items")

notebook.add(storage_box_tab, text="Storage Box")
notebook.pack(expand=1, fill="both")

my_label = tk.Label(window, text="Made by Alfazari911", anchor="e", padx=10)
my_label.pack(side="top", anchor="ne", padx=10, pady=5)

we_label = tk.Label(window, text="USE AT YOUR OWN RISK. EDITING STATS AND HP COULD GET YOU BANNED", anchor="w", padx=10)
we_label.pack(side="bottom", anchor="nw", padx=10, pady=5)

# Run 
window.mainloop()
